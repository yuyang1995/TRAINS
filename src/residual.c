/*!
 *  \file residual.c
 *  \brief calculate pulsar timing residuals of binary black holes
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>

#include "trains.h"

/*!
 *  This function calculates pulsar timing residuals generated by binary black holes. 
 *  (1) jp < 0: calculating residuals for all pulsars
 *  (2) jp >= 0: calculating residuals for pulsar jp
 */
void residual_cal(const void *pm, PSRmodel *p, double **t, double **res, double *phase, double *dis, int is, int jp)
{
  GWsource *s = (GWsource *)pm;
  int i = 0, j = 0, k = 0, ij = 0;
  double alphaS, sin_deltaS, cos_inc, psi, phi0, zeta, omega, tm;
  double cos_deltaS, sin_deltaP, cos_deltaP, alphatilde, cos_theta, dI, tau;
  double a[4], Pp, Pc, Fp, Fc, phiI, sC, sS, omegap, omegat, tmp;
  double DeltaC, DeltaS;

  for (i = 0; i < parset_pt.Ns; i++)
  {
    if (is >= 0 && i != is)
      continue;

    // coefficient for each source
    alphaS = s[i].alpha;
    sin_deltaS = s[i].sin_delta;
    cos_inc = s[i].cos_iota;
    psi = s[i].psi;
    phi0 = s[i].phi0;
    zeta = pow(10, s[i].log_zeta) / 2.0;
    omega = pow(10, s[i].log_omega);
    tm = pow(10, s[i].log_tm);

    a[0] = zeta * (1 + cos_inc * cos_inc) * cos(2 * psi);
    a[1] = -zeta * 2 * cos_inc * sin(2 * psi);
    a[2] = zeta * (1 + cos_inc * cos_inc) * sin(2 * psi);
    a[3] = zeta * 2 * cos_inc * cos(2 * psi);

    cos_deltaS = sqrt(1 - sin_deltaS * sin_deltaS);

    for (j = 0; j < parset_pt.Np; j++)
    {
      if (jp >= 0 && j != jp)
        continue;
      ij = i * parset_pt.Np + j;

      // antenna pattern functions
      alphatilde = alphaS - p[j].alpha;
      cos_deltaP = cos(p[j].delta);
      sin_deltaP = sin(p[j].delta);

      Pp = -pow(cos_deltaP, 2) * (1 - 2 * pow(cos(alphatilde), 2) + pow(cos(alphatilde), 2) * pow(cos_deltaS, 2)) + pow(sin_deltaP, 2) * pow(cos_deltaS, 2) - 2 * (sin_deltaP * cos_deltaP) * cos(alphatilde) * (sin_deltaS * cos_deltaS);

      Pc = -2 * cos_deltaP * sin(alphatilde) * (cos_deltaP * cos(alphatilde) * sin_deltaS - sin_deltaP * cos_deltaS);

      cos_theta = cos_deltaP * cos(p[j].alpha) * cos_deltaS * cos(alphaS) + cos_deltaP * sin(p[j].alpha) * cos_deltaS * sin(alphaS) + sin_deltaP * sin_deltaS;

      Fp = Pp / (1 - cos_theta);
      Fc = Pc / (1 - cos_theta);

      if (parset.flag_rec)
      {
        phiI = phase[ij];
        if (parset_pt.flag_evolve)
        {
          dI = dis[j];
          tau = dI * (1 - cos_theta);
        }
      }
      else
      {
        dI = p[j].d;
        tau = dI * (1 - cos_theta);
        if (parset_pt.flag_evolve)
          phiI = phi0 + 0.8 * omega * tm * (1 - pow(1 + tau / tm, 0.625));
        else
          phiI = phi0 - 0.5 * omega * tau;
        phiI = fmod(phiI, M_PI);
        phase[ij] = phiI;
      }

      if (parset_pt.flag_evolve)
      {
        // earth term
        sS = Fp * a[0] + Fc * a[2];
        sC = Fp * a[1] + Fc * a[3];
        for (k = 0; k < parset_pt.Nt; k++)
        {
          if (t[j][k] > tm)
            break;
          omegat = 2 * phi0 + 1.6 * omega * tm * (1 - pow((1 - t[j][k] / tm), 0.625));
          res[ij][k] = (sC * cos(omegat) + sS * sin(omegat)) * pow((1 - t[j][k] / tm), 0.125);
        }

        // pulsar term
        omegap = omega * pow((1 + tau / tm), -0.375);
        tmp = tm + tau;
        sC = sC * pow((1 + tau / tm), 0.125);
        sS = sS * pow((1 + tau / tm), 0.125);
        for (k = 0; k < parset_pt.Nt; k++)
        {
          if (t[j][k] > tmp)
            break;
          omegat = 2 * phiI + 1.6 * omegap * tmp * (1 - pow((1 - t[j][k] / tmp), 0.625));
          res[ij][k] -= (sC * cos(omegat) + sS * sin(omegat)) * pow((1 - t[j][k] / tmp), 0.125);
        }
      }
      else
      {
        DeltaC = cos(2 * phi0) - cos(2 * phiI);
        DeltaS = sin(2 * phi0) - sin(2 * phiI);
        sC = Fp * (DeltaC * a[1] + DeltaS * a[0]) + Fc * (DeltaC * a[3] + DeltaS * a[2]);
        sS = Fp * (-DeltaS * a[1] + DeltaC * a[0]) + Fc * (-DeltaS * a[3] + DeltaC * a[2]);

        for (k = 0; k < parset_pt.Nt; k++)
        {
          omegat = omega * t[j][k];
          res[ij][k] = sC * cos(omegat) + sS * sin(omegat);
        }
      }
    }
  }
  return;
}

void residual_sum(double **res_src, double **res, int jp)
{
  int i, j, k, ij;

  for (j = 0; j < parset_pt.Np; j++)
  {
    if (jp >= 0 && j != jp)
      continue;
    for (k = 0; k < parset_pt.Nt; k++)
      res[j][k] = 0;
  }

  for (i = 0; i < parset_pt.Ns; i++)
  {
    for (j = 0; j < parset_pt.Np; j++)
    {
      if (jp >= 0 && j != jp)
        continue;
      ij = i * parset_pt.Np + j;
      for (k = 0; k < parset_pt.Nt; k++)
        res[j][k] += res_src[ij][k];
    }
  }
  return;
}

void residual_shift(double **res, int jp)
{
  int j, k;
  double mean;
  for (j = 0; j < parset_pt.Np; j++)
  {
    if (jp >= 0 && j != jp)
      continue;
    mean = 0;
    for (k = 0; k < parset_pt.Nt; k++)
      mean += res[j][k];
    mean /= parset_pt.Nt;
    for (k = 0; k < parset_pt.Nt; k++)
      res[j][k] -= mean;
  }
}